#!/bin/sh
# https://github.com/basilioss/mdt

# Configuration ################################

dir="${MDT_DIR}"
inbox="${MDT_INBOX}"
color="${MDT_MAIN_COLOR:-5}"
prompt="${MDT_PROMPT:-◆}"
cursor="${MDT_CURSOR:-➔}"
item_width="${MDT_ITEM_WIDTH:-75}"
input_width="${MDT_INPUT_WIDTH:-65}"
file_editor="${MDT_EDITOR:-${EDITOR}}"

################################################

_me="${0##*/}"
_mdt_version="1.0.0"

print_help()
{
  printf %s "\
${_me} - command-line markdown todo list manager

Usage
  ${_me} [-d|--dir <arg>] [-i|--inbox <arg>] [--color <arg>]
  [--prompt <arg>] [--cursor <arg>] [--item-width <arg>]
  [--input-width <arg>] [--editor <arg>] [--version] [-h|--help]

Options
  -d, --dir           Path to the todos directory
  -i, --inbox         Path to the inbox note
  -h, --help          Print help
"
exit 0
}

parse_commandline()
{
  while test $# -gt 0
  do
    _key="$1"
    case "${_key}" in
      -d|--dir) dir="$2" && shift ;;
      --dir=*) dir="${_key##--dir=}" ;;
      -i|--inbox) inbox="$2" && shift ;;
      --inbox=*) inbox="${_key##--inbox=}" ;;
      --color) color="$2" && shift ;;
      --color=*) color="${_key##--color=}" ;;
      --prompt) prompt="$2" && shift ;;
      --prompt=*) prompt="${_key##--prompt=}" ;;
      --cursor) cursor="$2" && shift ;;
      --cursor=*) cursor="${_key##--cursor=}" ;;
      --item-width) item_width="$2" && shift ;;
      --item-width=*) item_width="${_key##--item-width=}" ;;
      --input-width) input_width="$2" && shift ;;
      --input-width=*) input_width="${_key##--input-width=}" ;;
      --editor) file_editor="$2" && shift ;;
      --editor=*) file_editor="${_key##--editor=}" ;;
      --version) printf "%s\n" "${_me} ${_mdt_version}" && exit ;;
      -h|--help) print_help ;;
      *) die "Got an unexpected argument '$1'" ;;
    esac
    shift
  done
}

# Search recursively for files that have specified checkboxes.
# By default, search for files that have any type of checkboxes.
# For example: [x] [ ] [-] [/] [>] [<] ...
# Exclude hidden directories and sort by modification time.
# Returns path to the file.
get_file_with_checkboxes() {
  cd "${dir}" && _file="$(grep -lZR --exclude-dir=".*" \
    "^[[:space:]]*- \[${1:-.}\]" \
    | xargs -0 ls -t | gum filter --no-strict \
    --indicator="${cursor}" \
    --prompt="${prompt} " \
    --indicator.foreground="${color}" \
    --match.foreground="${color}")"

  # Prompt to create a new file if it doesn't exist and if
  # checkbox type isn't specified.
  if [ -n "${_file}" ] && [ ! -f "${_file}" ] && [ -z "$1" ]; then
    gum confirm \
      --selected.background="${color}" \
      --selected.foreground="#262626" \
      --prompt.padding="0 2" \
      "File does not exist, create?"
    if [ $? -eq 0 ]; then
      printf "%s\n\n" "# ${_file}" > "${_file}.md"
      _file="${_file}.md"
    else
      exit
    fi
  fi

  [ -f "${_file}" ] && printf "%s\n" "${dir}/${_file}"
}

list_open_todos() {
  [ -f "$1" ] && _file="$1" || exit

  if ! grep -q "\- \[ \]" "${_file}" 2> /dev/null; then
    printf "%b\n" "Yey,\033[38;5;${color}m nothing\033[m left to do!" && exit
  fi

  _selected_items="$(grep "\- \[ ] " "${_file}" \
    | sed 's/^ \{0,1\}- \[ \] //g' \
    | sed 's/^[[:space:]]*- \[ \] /└─ /g' \
    | gum choose --no-limit \
    --item.width="${item_width}" \
    --cursor="${cursor} " \
    --cursor.foreground="${color}" \
    --selected.foreground="${color}" \
    --cursor-prefix "[ ] " \
    --selected-prefix "[✓] " \
    --unselected-prefix "[ ] ")"

  [ -z "${_selected_items}" ] && exit

  printf "%s\n" "${_selected_items}" | while read -r item; do
    escaped_item=$(printf '%s\n' "${item}" \
      | sed 's/└─ //g' \
      | sed 's/[*[\/&]/\\&/g')
    sed -i "s/\[ \] ${escaped_item}/\[x\] ${escaped_item}/g" "${_file}"
  done
}

add_todo() {
  [ -f "$1" ] && _file="$1" || exit

  _line="$(grep --line-number --extended-regexp \
    "\- \[.?]" "${_file}" | cut -d: -f1 | head -1)"
  _todo="$(gum input --prompt="${prompt} " \
    --prompt.foreground="${color}" \
    --width="${input_width}" \
    --placeholder "Got something to do?")"

  [ -z "${_todo}" ] && exit
  if [ -z "${_line}" ]; then
    printf "%s\n" "- [ ] ${_todo}" >> "${_file}"
  else
    sed -i "${_line}i - [ ] ${_todo}" "${_file}"
  fi
}

edit_todo() {
  [ -f "$1" ] && _file="$1" || exit
  [ -z "${file_editor}" ] && die "No editor specified"
  eval "${file_editor}" "\"${_file}\""
}

die() {
  printf 'Error: %s.\n' "$1" >&2
  exit 1
}

main() {
  which gum >/dev/null 2>&1 || die "gum is required but not installed, exiting"
  parse_commandline "$@"
  [ -d "${dir}" ] || die "No directory specified"

  _choice="$(gum choose \
    --cursor.foreground="${color}" \
    --cursor="${cursor} " \
    "List inbox" "Add inbox" "List" "Add" "Edit")"

  case "${_choice}" in
    "List")
      list_open_todos "$(get_file_with_checkboxes ' ')"
      ;;
    "List inbox")
      [ -f "${inbox}" ] || die "No inbox specified"
      list_open_todos "${inbox}"
      ;;
    "Add")
      add_todo "$(get_file_with_checkboxes)"
      ;;
    "Add inbox")
      [ -f "${inbox}" ] || die "No inbox specified"
      add_todo "${inbox}"
      ;;
    "Edit")
      edit_todo "$(get_file_with_checkboxes)"
      ;;
  esac
}

main "$@"
